# 운영체제 2024 가을 프로젝트

## 수학과 202021218 김재영

이 프로그램은 FIFO 방식의 named pipe를 통하여 클라이언트가 파일의 읽기나 쓰기 요청을 서버에 전달하여 서버가 요청에 대한 처리를 수행한 후 결과를 클라이언트에게 다시 전달하는 프로그램입니다.

## 구조
- `server.c` : 서버 프로그램으로 클라이언트 요청을 `request_pipe`를 통해 받아들이고 요청에 대한 처리를 수행하여 `response_pipe`를 통해 응답을 반환합니다.
- `client.c` : 클라이언트 프로그램으로 사용자로부터 입력을 받아 서버에 `request_pipe`를 통해 요청을 전달하고 수행된 결과를 `response_pipe`를 통해 받아 사용자에게 출력합니다.

## 작동방식

1. **FIFO 생성** : 서버가 시작될 때 클라이언트와 소통하기 위한 두 개의 named pipe를 생성합니다.
    - 요청 FIFO : `request_pipe`
    - 응답 FIFO : `response_pipe`

2. **FILE 형식** : 클라이언트는 `request_pipe`를 통해 서버에게 파일 접근을 요청합니다.
    - 파일 이름은 최대 100bytes
    - 파일에 작성될 데이터 용량은 최대 500bytes

3. **클라이언트 동작**
    - 클라이언트는 사용자가 입력한 명령에 따라 서버에 요청을 전송합니다.
    - **r** 읽기 요청의 경우 해당 파일 내 시작부터 입력된 byte 수만큼 데이터를 읽어 옵니다.
    - **w** 쓰기 요청의 경우 사용자가 입력한 데이터를 지정된 파일에 기록합니다.
    - **q** 종료 요청의 경우 클라이언트 프로그램은 서버에 종료 메세지를 전달한 후 클라이언트의 접속은 끊어집니다.
    - 클라이언트 프로그램은 종료 요청 명령이 들어올 때까지 무한 반복하며 사용자의 요청을 수행합니다.

    **예외처리**
    - 제공되는 명령이 아닌 다른 명령어를 입력할 시 오류 메세지를 출력합니다.
    - 읽기 요청으로 존재하지 않는 파일에 접근하게 될 시 오류 메세지를 출력합니다.
    - 파일의 접근 오류로 열리지 않거나 읽어들인 메세지가 없을 시 오류 메세지를 출력합니다.

4. **서버 동작**
    - 서버가 FIFO 파일 두 개를 생성합니다.
        - linux 명령에서 `mkfifo`가 존재하는 파일명으로 생성 시 서버를 종료하기 때문에 파일의 존재 여부를 확인합니다.
        - 만약 FIFO 파일이 존재한다면 서버 stdout에 파일이 존재한다는 메세지를 출력한 후 해당 FIFO 파일을 통해 클라이언트로부터 요청을 전달받습니다.
    - 서버는 클라이언트로부터 명령을 전달받아 요청에 맞는 작업을 수행합니다.
    - 서버가 클라이언트에게 `request_pipe`를 통해 명령을 입력받으면 `fork()`를 통해 child를 생성하여 명령을 수행하도록 전달합니다.
    - **r** 읽기 요청의 경우 해당 파일을 열어 입력된 byte수만큼 데이터를 전달합니다.
    - **w** 쓰기 요청의 경우 해당 파일을 쓰기 권한으로 열거나 쓰기 권한이 가능하도록 새로 생성하여 사용자로부터 입력받은 데이터를 해당 파일에 작성합니다.
    - 서버는 클라이언트의 명령을 수행한 후 클라이언트의 명령을 정리하여 서버 stdout에 어떠한 명령을 처리하였는지 정리하여 출력합니다.

## 실행 방법
1. 터미널을 통해 쉘 스크립트를 연다.
2. 다음 명령어를 통해 서버를 백그라운드로 실행한다.
    1. gcc -o server server.c
    2. ./server &
3. 다음 명령어를 통해 클라이언트를 실행시킨다.
    1. gcc -o client client.c
    2. ./client
4. 클라이언트의 제시된 요구사항을 수행하고자 하는 목적에 맞게 입력한다.
5. 서버를 통해 응답받은 데이터를 확인한다.
6. `q`를 통해 클라이언트를 종료한다.